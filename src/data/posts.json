[
  {
    "metadata": {
      "title": "Hello World",
      "publishedAt": "2020-07-04",
      "description": "Hello World"
    },
    "slug": "hello-world",
    "content": "Hello World! Classic.\n\nI decided to make a blog to write down some of the learning I make in my personal projects over on my [Github](https://github.com/alex-r89).\n\nSome of these projects are private, so not all of the learnings will relate to visible projects.\n\nI'll also post some random ramblings maybe, im not sure."
  },
  {
    "metadata": {
      "title": "Lowering Vercel Account Usage",
      "publishedAt": "2026-01-14",
      "description": "Lowering Vercel Account Usage"
    },
    "slug": "lowering-vercel-account-usage",
    "content": "I recently ran into an issue where, for some reason, my Vercel account usage was way, way higher than I would have expected. One of my side project websites was using up all of my edge requests (over a million in 30 days), all of my function invocations and a huge amount of my Fast Origin Transfer. The site wasn't getting more than 2,000-3,000 actual views a month, so something wasn't right.\n\nI fixed this by putting Cloudflare in front of the site...something I don't think Vercel likes. But it fixed it nonetheless.\n\n### Why my site usage was so high and why I couldn't do much about it on Vercel\n\nFor some reason, someone (unknown to me) had set up an uptime check on a non-existent API route on my site, and was pinging this route hundreds of times a minute. This was serving the 404 page thousands of times a day and naturally, this was counting towards the usages listed above.\n\nI started off by using Vercel's WAF to block all requests to the API route in question. I set up a custom rule to deny a request path and block it. This worked, and people could not make a request to `mywebsite.com/api/test` anymore.\n\nThe problem is, Vercel still counted these blocks as edge requests.\n\nI have no idea why this would be, as my thought is that this firewall rule would/should block these requests from making it to my server. The fact that they do seem to block them yet these blocks still count as edge requests, sort of makes the whole thing a bit pointless. Following on from that, it seems a little crazy to me that all you need to do to drain someone's entire monthly edge request limit is set up Uptimerobot to ping a Vercel site at `/random/path/here` every second. But that's why I wrote this blog post.\n\nFor whatever reason, only \"Persistent Actions\" don't count as edge requests, but persistent actions are only available on Pro and Enterprise plans - I am on the free tier.\n\n### How I put my site behind Cloudflare\n\nThis was fairly straightforward. The first step was to use Cloudflare's DNS. Step 2 was to then enable \"Full (Strict)\" in the \"Custom SSL/TLS\" settings, inside the SSL/TLS settings for my site.\n\nI then set up a custom security rule to block the request to the route entirely.\n\nThe only consideration to note here is that with the site being behind Cloudflare, all the IPs hitting Vercel's infrastructure are the same IP. This is where Vercel flagged to me that having my site behind Cloudflare would \"cause problems\". But I'm yet to see any of those problems.\n\nA thing to note here is that I could still get the client's IP using a different header, `CF-Connecting-IP`, which worked for rate limiting I had inside my API routes themselves.\n\nHere is a screen shot of my account usage before and after putting the site behind cloudflare:\n\n#### Edge Requests\n\n![Edge Requests](/images/edgeRequests.png 'Edge Requests')\n\n#### Function Invocations\n\n![Function Invocations](/images/functionInvocations.png 'Function Invocations')\n\n#### Fast Origin Transfer\n\n![Fast Origin Transfer](/images/fastOriginTransfer.png 'Fast Origin Transfer')\n\n### The End\n\nMaybe Vercel have changed this and you can now block these types of requests and limit your usage. But it's too late for me. I've been a bit disenfranchised by Vercel as a whole recently. Next.js has become harder and harder to work with, more and more of the features of Next.js seem to be locked to Vercel and things seem to be added to Next.js and then changed in the next major version so frequently, I lose track of what's happening if I'm not constantly looking at the Vercel socials.\n\nI've since moved the entire site off of Vercel onto Cloudflare Workers."
  },
  {
    "metadata": {
      "title": "Static Site Generation (SSG) with NextJS",
      "publishedAt": "2020-11-07",
      "description": "Statically generating paths using NextJS"
    },
    "slug": "nextjs-static-methods",
    "content": "While working on a side project, I decided to use SSR (via `getServerSideProps`) to build out paginated paths. The reason for this decision was that data on these pages is fairly dynamic, so I thought SSG was out of the question. Plus I wasn't sure how I would generate all of the pages at build time. The issue I ran into however was fairly slow metrics. The start render and First Contentful Paint were very poor at around 4.5 seconds:\n\n### Webpage Test SSR Vitals\n\n![SSR Webpage Test Score](/images/SSR.png 'SSR Webpage Test Score')\n\nAfter reading up on the NextJS documentation, looking and some of the NextJS examples ([found here](https://github.com/vercel/next.js/tree/canary/examples)) and asking in the Github discussions section, I found out that I could use NextJS to statically generate the paths (i.e. `/page/2`) as well as statically generate pages, while not needing to worry about stale data on the page.\n\n### Generating static pages with `getStaticProps`\n\nThe first problem to solve was to work out how to generate a page statically to improve the metrics above. Thankfully, this is fairly straight forward using `getStaticProps`. The `getStaticProps` method replaces `getServerSideProps` and is exported at the bottom of pages in the same way. This allows you to carry out usual data fetches to populate a page at build time. For my personal project, I make calls to my _GraphQL_ resolvers here to fetch information required in the page:\n\n```javascript\nexport async function getStaticProps({ params }) {\n  const apolloClient = await initApolloClient({})\n\n  const { data: allServers } = await apolloClient.query({\n    query: getServersQuery,\n    variables: { input: { page: parseInt(params.index), getSponsoredOnly: false } }\n  })\n\n  const apolloStaticCache = apolloClient.cache.extract()\n  return {\n    props: {\n      servers: allServers?.getServers,\n      page: params?.index,\n      apolloStaticCache\n    },\n    // update every 30 mins\n    revalidate: 1800 // Remove if using SSR\n  }\n}\n```\n\nThis allows me to call my `getServersQuery` resolver, fetch the data I need at build time and have this route statically rendered. This data is then returned from this method, which is simply passed into my page component as props:\n\n```javascript\nconst PaginatedPage = ({ servers, page }) => {\n...\n// more code here and stuff\n...\n```\n\nThere are two other things to explain in the code snippet above, `params` and `revalidate`.\n\n### Using `revalidate` to update statically generated page data\n\nThe optional `revalidate` parameter allows for [Incremental Static Regeneration](https://nextjs.org/docs/basic-features/data-fetching#incremental-static-regeneration), which essentially solves the issue of data going stale. With this paramaeter added to `getStaticProps`, the page will be re-generated after a set number of seconds as traffic comes in. In my case above, every 1800 seconds (or 30 minutes) this page will be re-built once traffic hits the route, meaning I dont need to rebuild my entire application to get new data from the `getServersQuery` resolver.\n\n### Building routes statically using `getStaticPaths`\n\nThis is where `params` comes in. The second issue I faced was needing to generate multiple paginatable pages at build time. How would I know how many pages I needed to build? For example, if a company had 400 products, with 20 products per page, how would they know to build 20 pages, allowing a user to go to `/page/15` and see a statically generated (fast) page of products. This is solved by `getStaticPaths`.\n\n`getStaticPaths` allows you to generate the paths you need statically. In my case, I needed to work out how many pages I have, based on a calculation of the total amount of `servers` divided by the amount of `servers` per page. I would then generate an array of this total, and iterate over it using a `map` to generate page index's:\n\n```javascript\nexport async function getStaticPaths() {\n  const SERVERS_PER_PAGE = 20\n  ...\n  ...\n  // removed code here that gets totalServerCount\n  ...\n  ...\n\n  const numberOfPages = Math.ceil(totalServerCount / SERVERS_PER_PAGE)\n\n  // - 1 here because the array counts from 0\n  const paths = Array(numberOfPages - 1)\n    .fill('')\n    .map((_, index) => ({\n      // We + 2 here because pages start at  page/2\n      // Need to use toString() because getStaticProps needs string\n      params: { index: (index + 2).toString() }\n    }))\n  // fallback: false means pages that don’t have the\n  // correct id will 404.\n  return { paths, fallback: true }\n}\n```\n\nThe return from `getStaticPaths` is the paths that can be generated. This is passed into `getStaticProps` as the `param` prop, which then generates this path. AMAZING! But what is `fallback`?\n\n### Building future routes using `fallback`\n\nThere is an issue with the explanation above. What happens if a company was to add 400 new products, and needed 20 new page routes for these (i.e. allowing a user to go to `/page/55`). This is solved with `fallback`.\n\nIf the above scenario was to happen, and a user was to visit `/page/21` which wasnt generated in our first example, this page would cause the `fallback` to occour. This will cause this route to be generated on the fly, and from then on be a static route. The initial user would see a loading screen, and this would need to be accounted for in the front end, but subsiquent users would see a statically generated page. I solve this using the following code in my page:\n\n```javascript\nconst PaginatedPage = ({ servers, page }) => {\n  const router = useRouter()\n\n  if (router.isFallback) {\n    return <span>Loading...</span>\n  }\n```\n\n`next/router` allows us to access an `isFallback` parameter, which is passed from `getStaticPaths` `fallback`. As you can see, this first render will see a `span` with Loading... in it, but subsiquent users will see the statically generated path, if it exists, and a `404` if it does not.\n\nNICE!\n\nThe result from the above was that page load speeds halved:\n\n### Webpage Test SSG Vitals\n\n![SSG Webpage Test Score](/images/SSG.png 'SSG Webpage Test Score')"
  },
  {
    "metadata": {
      "title": "Proxying requests in NextJS",
      "publishedAt": "2020-08-05",
      "description": "Cool stuff related to Static Site Generation, API Routes and Proxying requests in NextJS"
    },
    "slug": "proxying-requests-with-next-js",
    "content": "## The Task\n\nI was tasked with creating a proof of concept within a small team at work (I currently work at one of the largest ecommerce sites in the UK). This concept project was to use SSG (Static Site Generation) to populate a product card, which would greatly improve the performance of the component/page because just static HTML/CSS files can be sent to the client.\n\n## The Problem\n\nSSG means that the page is rendered at build time. Although this is fantastic for performance, a caveat is that data fetched at build time is what is sent to the client. If this data changes after the build, for example if the price changed, the page or component wont reflect that change (unless another build is kicked off). With that in mind, I needed to work out how to fetch the more dynamic data on request/on the client.\n\n## The Solution\n\nThe first solution was to build a [custom server](https://nextjs.org/docs/advanced-features/custom-server) using express. This worked instantly and solved the problem - the client side fetch worked, however this seems to be a pattern NextJS is moving away from. After reading the documentation some more, I found out that API Routes (\"_a straightforward solution to building an API with Next.js_\") coupled with some rerwrites via a `next.config.js` file could also solve this problem with a lot less code.\n\n### API Route\n\nThe first step was to create an `api` folder inside of the `pages` folder. This folder must **explicitly** be called `api`.\n\nWithin this api folder structure, all we need to do is to create a file for our API. The naming convention for this on the vercel docs is usually a file name inside square brackets. I went for `[...args].js`. Any files placed inside this folder are essentially API's, which could carry out any usual tasks a conventional API (like an express server) may do.\nThe code for proxying the requests is fairly straight forward using the `http-proxy-middleware` package, found [here](https://github.com/chimurai/http-proxy-middleware):\n\n```javascript\nconst apiProxy = createProxyMiddleware({\n  target: 'https://www.big-uk-ecommerce-site.co.uk',\n  changeOrigin: true,\n  pathRewrite: {\n    [`api/product-api/pdp-service/partNumber/`]: 'product-api/pdp-service/partNumber/'\n  },\n  secure: false\n})\n```\n\nVercel's API Route gives us access to a `req` and `res` object (much like we would get using an express server) which we then pass into the `apiProxy` created above:\n\n```javascript\nexport default function (req, res) {\n  apiProxy(req, res, (result) => {\n    if (result instanceof Error) {\n      throw result\n    }\n\n    throw new Error(`Request '${req.url}' is not proxied! We should never reach here!`)\n  })\n}\n```\n\nThe full code for this can be found [here](https://github.com/alex-rhodes/nextjs-poc/blob/master/pages/api/%5B...args%5D.js).\n\n### NextJS config Redirect\n\nThe final piece of the puzzle is to use a Next config. A NextJS config is a regular Node.js module, not a JSON file. It gets used by the Next.js server and build phases, and it's not included in the browser build. This file (named `next.config.js`) is placed into the root of our project.\n\nThis file can do a number of things, however the code I needed to use is fairly straight forward; it simply rewrites the request path of the source request to the companies actual product API:\n\n```javascript\nmodule.exports = {\n  rewrites: () => [\n    {\n      source: 'api/product-api/pdp-service/partNumber/*',\n      destination: 'https://www.big-uk-ecommerce-site.co.uk/product-api/pdp-service/partNumber/*'\n    }\n  ]\n}\n```\n\nAnd thats it! Coupled with the API route, this next config is all we need to proxy requests using Next.\n\nBonus: The performance of this app was also fantastic, the LightHouse and Web Page Test results are shown below\n\n## Lighthouse:\n\n![Lighthouse Score](/images/lighthouse.png 'Lighthouse Score')\n\n## WebPageTest (Moto 4G, 3G connection):\n\n![Webpage Test Score](/images/wpt.png 'Webpage Test Score')\n\nAs always, thanks for reading!"
  },
  {
    "metadata": {
      "title": "Ranking ordered Postgres queries using TypeOrm",
      "publishedAt": "2020-07-10",
      "description": "How to implement Postgres ROW_NUMBER to \"rank\" ordered queries using TypeOrm"
    },
    "slug": "typeorm-row-number",
    "content": "## The Task\n\nTL;DR - Scroll down to the code below for the solution (Solution 2).\n\nIn one of my personal projects, I fire a GraphQL query to a Postgres table of `Server` entities when a user visits a page. With the option to pass in an offset for pagination, this query returns an array of up to 20 `Servers`, ordered by a column in the table (`vote_count`).\n\n## The Problem\n\nThe issue I was facing is that on the front-end I needed to \"rank\"/numerically order these results - essentially getting their position as an integer in the returned query. For example, the first 20 results will be `rank` 1-20, page 2 will be `rank` 21-40 and so on. However, I was unsure how to best do this.\n\nIt seemed like storing this rank in the database was a mistake. If a vote for a server came in, I would also need to calculate the rank of the server there and then, which would be based on working out if this vote changed the position of this server in the table, e.g. add 1 to that servers `vote_count` and then also work out if that changes the `Server` from rank 10 to rank 9 - if it does, change the ranks some how. Very messy.\n\nWith that being said, my first thought was to calculate this on the fly (either in my `getServers` `Resolver` after the query or on the front end), by working out the rank based on a calculation of the offset and the position of the `Server` in the returned array of 20. However this seemed like a slow, janky and potentially error prone way of working it out.\n\nAfter Googling for a few hours, I found out that Postgres provides a method of working this out via its [ROW_NUMBER](https://www.postgresqltutorial.com/postgresql-row_number/) function. This function returns exactly what I was after - a unique integer value to each row in a result set.\nThe next problem was working out how to do this with Typeorm!\n\n## The Solution\n\nTypeorm is great...once you work out how to do something. However, I find the documentation lacks a little and seems to be written by someone who expects the reader to have implied knowledge of Typeorm. I don't have a clue what I'm doing, so was poking in the dark\n\nI assumed that Typeorm's `find` method would have some way of using the `ROW_NUMBER` function. However after searching and trial and erroring, I found out that for some reason it doesn't - so needed to use Typeorm's Query Builder.\n\n## Solution 1 (❌)\n\nAfter googling for a while, I worked out that I could return the row number/rank via the `addSelect` method, like so:\n\n`.addSelect('ROW_NUMBER () OVER (ORDER BY \"vote_count\" DESC) as \"rank\"')`\n\nHowever, the problem I was seeing next was that the row number wasn't returned. After pulling my hair out for hours, I found out that `getMany()` doesnt return `row_number` - it only returns the values of the defined entity.\n\nFor reference, this is the full **incorrect** solution:\n\n```javascript\nconst response = await getConnection()\n  .createQueryBuilder()\n  .select('server')\n  .addSelect('ROW_NUMBER () OVER (ORDER BY \"vote_count\" DESC) as \"rank\"')\n  .from(Server, 'server')\n  .where('is_sponsored = true')\n  .offset(0)\n  .limit(20)\n  .getMany()\n```\n\nAll I needed to do from here was to use `getRawMany()` instead of `getMany()`:\n\n## Solution 2 (✅)\n\n```javascript\nconst response = await getConnection()\n  .createQueryBuilder()\n  .select('server')\n  .addSelect('ROW_NUMBER () OVER (ORDER BY \"vote_count\" DESC) as \"rank\"')\n  .from(Server, 'server')\n  .where('is_sponsored = true')\n  .offset(0)\n  .limit(20)\n  .getRawMany() // <- getRawMany DOES return the row number\n```\n\nLast but not least, I needed to change the return object from my resolver to match the \"raw\" result.\n\nAnd that's it! The above code adds a rank/order value to a query result in Postgres using Typeorm!\n\nThanks for reading!"
  }
]